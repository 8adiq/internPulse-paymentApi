import pytest
from unittest.mock import patch, MagicMock
from decimal import Decimal
from payments.service import PaymentService, PaystackService
from payments.models import Payment

@pytest.mark.django_db
class TestPaymentService:
    """Test cases for PaymentService using pytest"""
    
    @pytest.fixture
    def valid_payment_data(self):
        """Fixture for valid payment data"""
        return {
            'customer_name': 'John Doe',
            'customer_email': 'john@example.com',
            'phone_number': '1234567890',
            'state': 'Lagos',
            'country': 'Nigeria',
            'amount': '50.00',
            'currency': 'NGN'
        }
    
    def test_generate_payment_reference(self):
        """Test payment reference generation"""
        ref1 = PaymentService.generate_payment_reference()
        ref2 = PaymentService.generate_payment_reference()
        
        assert isinstance(ref1, str)
        assert isinstance(ref2, str)
        assert ref1.startswith('PAY-')
        assert ref2.startswith('PAY-')
        assert ref1 != ref2  # Should be unique
        assert len(ref1) == 12  # PAY- + 8 characters
        assert len(ref2) == 12
    
    @patch('payments.service.PaystackService.initiate_payment')
    def test_create_payment_success(self, mock_paystack, valid_payment_data):
        """Test successful payment creation"""
        # Mock Paystack response
        mock_paystack.return_value = {
            'success': True,
            'authorization_url': 'https://checkout.paystack.com/abc123',
            'reference': 'PAY-TEST123',
            'access_code': 'abc123',
            'message': 'Payment initiated successfully'
        }
        
        result = PaymentService.create_payment(valid_payment_data)
        
        assert result['success'] is True
        assert 'payment' in result
        assert result['payment']['customer_name'] == 'John Doe'
        assert result['payment']['customer_email'] == 'john@example.com'
        assert result['payment']['amount'] == '50.00'
        assert result['payment']['status'] == 'pending'
        
        # Verify payment was saved to database
        payment = Payment.objects.get(customer_email='john@example.com')
        assert payment.customer_name == 'John Doe'
        assert payment.paystack_authorization_url == 'https://checkout.paystack.com/abc123'
        # Note: paystack_reference is generated by the service, not from mock
    
    @patch('payments.service.PaystackService.initiate_payment')
    def test_create_payment_paystack_failure(self, mock_paystack, valid_payment_data):
        """Test payment creation when Paystack fails"""
        # Mock Paystack failure
        mock_paystack.return_value = {
            'success': False,
            'message': 'Paystack API error'
        }
        
        result = PaymentService.create_payment(valid_payment_data)
        
        assert result['success'] is False
        assert 'Paystack API error' in result['message']
        
        # Verify payment was still created in database
        payment = Payment.objects.get(customer_email='john@example.com')
        assert payment.customer_name == 'John Doe'
        assert payment.status == 'pending'
    
    def test_create_payment_invalid_data(self):
        """Test payment creation with invalid data"""
        invalid_data = {
            'customer_name': 'John Doe',
            # Missing required fields
            'amount': '50.00'
        }
        
        result = PaymentService.create_payment(invalid_data)
        
        assert result['success'] is False
        assert 'errors' in result
        assert 'customer_email' in result['errors']
        assert 'phone_number' in result['errors']
        assert 'state' in result['errors']
        assert 'country' in result['errors']
    
    def test_create_payment_invalid_amount(self):
        """Test payment creation with invalid amount"""
        invalid_data = {
            'customer_name': 'John Doe',
            'customer_email': 'john@example.com',
            'phone_number': '1234567890',
            'state': 'Lagos',
            'country': 'Nigeria',
            'amount': '-10.00',  # Negative amount
            'currency': 'NGN'
        }
        
        result = PaymentService.create_payment(invalid_data)
        
        assert result['success'] is False
        assert 'errors' in result
        assert 'amount' in result['errors']
    
    def test_get_payment_success(self, valid_payment_data):
        """Test getting existing payment"""
        # Create a payment first
        payment = Payment.objects.create(
            customer_name=valid_payment_data['customer_name'],
            customer_email=valid_payment_data['customer_email'],
            phone_number=valid_payment_data['phone_number'],
            state=valid_payment_data['state'],
            country=valid_payment_data['country'],
            amount=Decimal(valid_payment_data['amount']),
            currency=valid_payment_data['currency']
        )
        
        result = PaymentService.get_payment(str(payment.id))
        
        assert result['success'] is True
        assert result['payment']['id'] == str(payment.id)
        assert result['payment']['customer_name'] == 'John Doe'
        assert result['payment']['customer_email'] == 'john@example.com'
        assert result['payment']['amount'] == '50.00'
        assert result['payment']['status'] == 'pending'
    
    def test_get_payment_not_found(self):
        """Test getting non-existent payment"""
        import uuid
        fake_id = str(uuid.uuid4())
        
        result = PaymentService.get_payment(fake_id)
        
        assert result['success'] is False
        assert 'Payment not found' in result['message']
    
    def test_get_payment_invalid_uuid(self):
        """Test getting payment with invalid UUID"""
        invalid_id = 'not-a-uuid'
        
        result = PaymentService.get_payment(invalid_id)
        
        assert result['success'] is False
        assert 'Error retrieving payment' in result['message']
    
    @patch('payments.service.PaystackService.initiate_payment')
    def test_create_payment_transaction_rollback(self, mock_paystack, valid_payment_data):
        """Test that database transaction rolls back on Paystack failure"""
        # Mock Paystack to raise an exception
        mock_paystack.side_effect = Exception("Network error")
        
        # Count payments before
        initial_count = Payment.objects.count()
        
        result = PaymentService.create_payment(valid_payment_data)
        
        # Count payments after
        final_count = Payment.objects.count()
        
        assert result['success'] is False
        assert 'Network error' in result['message']
        # Payment should not be created due to transaction rollback
        assert final_count == initial_count

@pytest.mark.django_db
class TestPaystackService:
    """Test cases for PaystackService using pytest"""
    
    @pytest.fixture
    def payment_instance(self):
        """Fixture that creates a Payment instance"""
        return Payment.objects.create(
            customer_name='John Doe',
            customer_email='john@example.com',
            phone_number='1234567890',
            state='Lagos',
            country='Nigeria',
            amount=Decimal('50.00'),
            currency='NGN',
            paystack_reference='PAY-TEST123'
        )
    
    def test_get_headers(self):
        """Test headers generation"""
        headers = PaystackService.get_headers()
        
        assert 'Authorization' in headers
        assert 'Content-Type' in headers
        assert headers['Content-Type'] == 'application/json'
        assert headers['Authorization'].startswith('Bearer ')
    
    @patch('payments.service.requests.post')
    def test_initiate_payment_success(self, mock_post, payment_instance):
        """Test successful payment initiation"""
        # Mock successful response
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            'status': True,
            'data': {
                'authorization_url': 'https://checkout.paystack.com/abc123',
                'reference': 'PAY-TEST123',
                'access_code': 'abc123'
            }
        }
        mock_post.return_value = mock_response
        
        result = PaystackService.initiate_payment(payment_instance)
        
        assert result['success'] is True
        assert result['authorization_url'] == 'https://checkout.paystack.com/abc123'
        assert result['reference'] == 'PAY-TEST123'
        
        # Verify payment was updated
        payment_instance.refresh_from_db()
        assert payment_instance.paystack_authorization_url == 'https://checkout.paystack.com/abc123'
    
    @patch('payments.service.requests.post')
    def test_initiate_payment_failure(self, mock_post, payment_instance):
        """Test failed payment initiation"""
        # Mock failed response
        mock_response = MagicMock()
        mock_response.status_code = 400
        mock_response.json.return_value = {
            'status': False,
            'message': 'Invalid amount'
        }
        mock_post.return_value = mock_response
        
        result = PaystackService.initiate_payment(payment_instance)
        
        assert result['success'] is False
        assert 'Invalid amount' in result['message']
    
    @patch('payments.service.requests.post')
    def test_initiate_payment_network_error(self, mock_post, payment_instance):
        """Test payment initiation with network error"""
        # Mock network error
        mock_post.side_effect = Exception("Network connection failed")
        
        result = PaystackService.initiate_payment(payment_instance)
        
        assert result['success'] is False
        assert 'Network connection failed' in result['message']
    
    @patch('payments.service.requests.post')
    def test_initiate_payment_invalid_response(self, mock_post, payment_instance):
        """Test payment initiation with invalid response"""
        # Mock invalid response
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            'status': False,  # Paystack returned False
            'message': 'Invalid request'
        }
        mock_post.return_value = mock_response
        
        result = PaystackService.initiate_payment(payment_instance)
        
        assert result['success'] is False
        assert 'Invalid request' in result['message']
    
    def test_process_webhook_success(self, payment_instance):
        """Test successful webhook processing"""
        webhook_data = {
            'event': 'charge.success',
            'data': {
                'reference': 'PAY-TEST123',
                'status': 'success',
                'amount': 5000,
                'id': 123456789
            }
        }
        
        result = PaystackService.process_webhook(webhook_data)
        
        assert result['success'] is True
        assert 'Payment processed successfully' in result['message']
        
        # Verify payment status was updated
        payment_instance.refresh_from_db()
        assert payment_instance.status == 'completed'
        assert payment_instance.paystack_transaction_id == '123456789'
    
    def test_process_webhook_failed_payment(self, payment_instance):
        """Test webhook processing for failed payment"""
        webhook_data = {
            'event': 'charge.failed',
            'data': {
                'reference': 'PAY-TEST123',
                'status': 'failed',
                'amount': 5000,
                'id': 123456789
            }
        }
        
        result = PaystackService.process_webhook(webhook_data)
        
        assert result['success'] is True
        
        # Verify payment status was updated
        payment_instance.refresh_from_db()
        assert payment_instance.status == 'failed'
    
    def test_process_webhook_payment_not_found(self, payment_instance):
        """Test webhook processing for non-existent payment"""
        webhook_data = {
            'event': 'charge.success',
            'data': {
                'reference': 'PAY-NONEXISTENT',
                'status': 'success',
                'amount': 5000,
                'id': 123456789
            }
        }
        
        result = PaystackService.process_webhook(webhook_data)
        
        assert result['success'] is False
        assert 'Payment with reference' in result['message']
    
    def test_process_webhook_invalid_data(self):
        """Test webhook processing with invalid data"""
        webhook_data = {
            'invalid': 'data'
        }
        
        result = PaystackService.process_webhook(webhook_data)
        
        assert result['success'] is False
        assert 'Unhandled webhook event' in result['message']
    
    def test_process_webhook_unsupported_event(self, payment_instance):
        """Test webhook processing with unsupported event"""
        webhook_data = {
            'event': 'unsupported.event',
            'data': {
                'reference': 'PAY-TEST123',
                'status': 'success',
                'amount': 5000,
                'id': 123456789
            }
        }
        
        result = PaystackService.process_webhook(webhook_data)
        
        assert result['success'] is False
        assert 'Unhandled webhook event' in result['message']
    
    @patch('payments.service.requests.post')
    def test_initiate_payment_payload_structure(self, mock_post, payment_instance):
        """Test that the correct payload is sent to Paystack"""
        # Mock successful response
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            'status': True,
            'data': {
                'authorization_url': 'https://checkout.paystack.com/abc123',
                'reference': 'PAY-TEST123',
                'access_code': 'abc123'
            }
        }
        mock_post.return_value = mock_response
        
        PaystackService.initiate_payment(payment_instance)
        
        # Verify the correct payload was sent
        mock_post.assert_called_once()
        call_args = mock_post.call_args
        
        # Check URL
        assert 'transaction/initialize' in call_args[0][0]
        
        # Check headers
        headers = call_args[1]['headers']
        assert headers['Content-Type'] == 'application/json'
        assert headers['Authorization'].startswith('Bearer ')
        
        # Check payload
        payload = call_args[1]['json']
        assert payload['amount'] == 5000  # Amount in kobo
        assert payload['email'] == 'john@example.com'
        assert payload['reference'] == 'PAY-TEST123'
